<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
    <link rel="stylesheet" href="styles.css">
    <title>OOP</title>
</head>
<body>
<div id="document">
    <nav id="navbar">
        <header id="header"><h1>Object-Oriented Programming</h1></header>
        <ul id="menu-items">
            <li><a href="#foundations" class="nav-link">Foundations</a></li>
            <li><a href="#examples" class="nav-link">Examples</a></li>
            <li><a href="#private_attributes" class="nav-link">Private Attributes</a></li>
            <li><a href="#properties" class="nav-link">Properties</a></li>
            <li><a href="#section_5" class="nav-link">Section 5</a></li>
            <li><a href="#references" class="nav-link">References</a></li>
        </ul>
    </nav>
    <main id="main-doc">
        <div id="document-body">
            <section id="foundations" class="main-section">
                <header><h2>Foundations</h2></header>
                <article>
                    <p>"<b>Object-Oriented Programming</b> ( <b>OOP</b> ) is a
                        <a href="/wiki/Programming_paradigm" title="Programming paradigm">
                            programming paradigm</a> based on the concept of "
                        <a href="/wiki/Object_(computer_science)" title="Object (computer science)">
                            objects</a> ", which can contain
                        <a href="/wiki/Data" title="Data">data</a> and
                        <a href="/wiki/Computer_program" title="Computer program">code</a>
                        . The data is in the form of
                        <a href="/wiki/Field_(computer_science)" title="Field (computer science)">
                            fields</a> (often known as
                        <a href="/wiki/Attribute_(computing)" title="Attribute (computing)">
                            attributes</a> or <i>properties</i>
                        ), and the code is in the form of procedures (often known as
                        <i><a href="/wiki/Method_(computer_science)" class="mw-redirect"
                              title="Method (computer science)">methods</a></i> )."<a class="ref" href="#ref1"><sup>1</sup></a></p>
                    <p>This technical document will show how to create some object-oriented programs
                        exploring the underlying concepts including a forerunner and component of
                        languages supporting Object-Oriented Programming.</p>
                    <p>Programming is an art that allows a representation of something, real or imaginary,
                        such that it might be interacted with on some basis. The process of writing programs
                        can be made more intuitive through the application of concepts and paradigms that also
                        improve their maintainability. Object-Oriented Programming can solve problems that may
                        be much more difficult to solve otherwise using a strictly procedural approach.</p>
                    <p>It is important to remember that underpinning many languages supporting Object-Oriented
                        Programming, is procedural programming which often coexists in the language. Python is
                        one such language and the sections that follow will utilize Python for the provided
                        snippets and examples.</p>
                    <p>Object programming can make large, complex projects more manageable by:</p>

                    <ul>
                        <li>splitting the project into smaller components;</li>
                        <li>independently developing the component parts;</li>
                    </ul>

                    <p>Constructing an object in Python is as simple as using the class keyword, choosing a name
                        for the object and whether to add any properties and functions to the object.</p>

                    <p>The following is an example of a very simple object with no properties or functions.</p>
                    <div class="code-block">
<pre>
<p-kw>class</p-kw> Recipe():
   <p-kw>pass</p-kw>
</pre>
                    </div>

                    <p>Create an usable instance of the new Recipe object is done as below where a name is chosen
                        and then assigned an instance of the object.</p>
                    <div class="code-block">
<pre>recipe = Recipe()</pre>
                    </div>
                </article>
            </section>
            <section id="examples" class="main-section">
                <header><h2>Examples</h2></header>
                <article>
                    <h3>Attacking with procedures</h3>
                    <p>Consider a procedural approach to programming a stack consisting of an array that utilizes
                    two functions - one function pushes elements onto the array and the other function 'pops' the
                    last element off. The classic Last In First Out (LIFO) model.</p>
                    <p>Let's define an array for the stack.</p>
                    <div class="code-block">
<pre>stack = []</pre>
                    </div>
                    <p>Now let's write the function to push elements onto the array.  The <code>push</code> function takes a value
                    and appends it to the array.</p>
                    <div class="code-block">
<pre>
<p-kw>def</p-kw><p-name> push</p-name>(value):
   stack.append(value)
</pre>
                    </div>
                    <p>The remaining item is to write a <code>pop</code> function that takes no arguments but returns and deletes
                        the last array element.</p>
                    <div class="code-block">
<pre>
<p-kw>def</p-kw><p-name> pop</p-name>():
    element = stack[-<p-int>1</p-int>]
    <p-kw>del</p-kw> (stack[-<p-int>1</p-int>])
    <p-kw>return</p-kw> element
</pre>
                    </div>
                    <p>Now let's test the stack by pushing three elements onto it and then popping them off again.</p>
                    <div class="code-block">
<pre>
push(<p-int>3</p-int>)
push(<p-int>2</p-int>)
push(<p-int>1</p-int>)

<p-prt>print</p-prt>(pop())
<p-prt>print</p-prt>(pop())
<p-prt>print</p-prt>(pop())
</pre>
                    </div>
                    <p>The results below are shown in the order printed to the console.</p>
                    <div class="code-block">
<pre>
1
2
3
</pre>
                    </div>
                    <p>The stack works beautifully and has pros and cons some of which are listed below.</p>
                    <ul>
                        <li>There can only ever be one stack using this procedural approach;</li>
                        <li>The data exists separately from the code;</li>
                    </ul>
                    <h3>Object-oriented thinking</h3>
                    <p>Now let's think about the problem using an object-oriented approach.  To build a stack
                        object, an array is required as a property in addition to <code>push</code> and <code>pop</code> functions as before.
                    The difference this time is that all of these features will be encapsulated in one object.</p>
                    <p>Creating a new object begins with the class keyword and a descriptive name for the object
                        about to be created, in this case a stack.</p>
                    <div class="code-block">
<pre>
<p-kw>class</p-kw> Stack:
</pre>
                    </div>
                    <div class="note">
                        <aside>Note: Convention states that object names be capitalised camel-case.<a class="ref" href="#ref4"><sup>4</sup></a>
                        </aside>
                    </div>
                    <p>The Stack object will have to be initialised with an array which will be named <code>stack</code>.
                    The initialization is accomplished automatically through the use of a special in-built
                    function named "__init__" also known as a constructor.  The constructor must have at least
                        one parameter and by convention the parameter uses the name <code>self</code>. Adding that to our
                        code will look as follows.</p>
                    <div class="code-block">
<pre>
<p-kw>class</p-kw> Stack:
    <p-kw>def </p-kw><p-bi>__init__</p-bi>(<p-slf>self</p-slf>):
        <p-slf>self</p-slf>.stack = []
</pre>
                    </div>
                    <p>The <code>self</code> parameter is used to represent an instance of a given object and allows the
                    instances of the object to hold attribute values independently.<a class="ref" href="#ref5"><sup>5
                        </sup></a></p>
                    <p>Completing the Stack object requires the addition of the <code>push</code> and <code>pop</code> functions. Essentially, the functions can be copied and pasted into the class object but instantiation must be considered.  Therefore, the self parameter must be inserted as the first parameter in each function's list of parameters.  The self parameter name must also be used to access parameter values. </p>
                    <p>Adding the <code>push</code> function first will change the class object as below.</p>
                    <div class="code-block">
<pre>
<p-kw>class</p-kw> Stack:
    <p-kw>def </p-kw><p-bi>__init__</p-bi>(<p-slf>self</p-slf>):
        <p-slf>self</p-slf>.stack = []

    <p-kw>def</p-kw><p-name> push</p-name>(<p-slf>self</p-slf>, value):
        <p-slf>self</p-slf>.stack.append(value)
</pre>
                    </div>
                    <p>Finally, the <code>pop</code> function can be included with the same considerations as used when appending the <code>push</code> function.</p>
                    <div class="code-block">
<pre>
<p-kw>class</p-kw> Stack:
    <p-kw>def </p-kw><p-bi>__init__</p-bi>(<p-slf>self</p-slf>):
        <p-slf>self</p-slf>.stack = []

    <p-kw>def</p-kw><p-name> push</p-name>(<p-slf>self</p-slf>, value):
        <p-slf>self</p-slf>.stack.append(value)

    <p-kw>def</p-kw><p-name> pop</p-name>(<p-slf>self</p-slf>):
        element = <p-slf>self</p-slf>.stack[-<p-int>1</p-int>]
        <p-kw>del</p-kw> <p-slf>self</p-slf>.(stack[-<p-int>1</p-int>])
        <p-kw>return</p-kw> element
</pre>
                    </div>
                    <p>Testing the new class object is all that remains.  A class instance can be created through assignment like so:</p>
                    <div class="code-block">
<pre>
stack_instance = Stack()
</pre>
                    </div>
                    <p>The instance created above uses familiar function notation.<a class="ref" href="#ref6"><sup>6
                        </sup></a></p>
                    <p>The <code>stack</code> array or data attribute and the methods - a method is a function belonging to an object<a class="ref" href="#ref7"><sup>7
                        </sup></a> - defined in the Stack class object is now accessible in the
                        <code>stack_instance</code> class instance via dot notation.</p>
                    <p>Pushing and popping items on and off the stack is as shown below with the print results following the '#' character.</p>
                    <div class="code-block">
<pre>
stack_instance.push(<p-int>3</p-int>)
stack_instance.push(<p-int>2</p-int>)
stack_instance.push(<p-int>1</p-int>)

<p-prt>print</p-prt>(stack_instance.pop())  # 1
<p-prt>print</p-prt>(stack_instance.pop())  # 2
<p-prt>print</p-prt>(stack_instance.pop())  # 3
</pre>
                    </div>
                    <p>Since no errors were displayed in the execution of the methods contained within the <code>stack_instance</code>
                        instantiation and the LIFO mechanism appears to be functioning correctly, (excuse the pun), judging by the results
                        of the console prints, it could be considered safe to assume the code is working.  It is possible to dig a little
                        deeper to further verify this conclusion.</p>
                    <p>Lists, as arrays are known in Python, behave in a very predictably.  Using this information we can ask for the
                        current length of the list, then again after pushing some values on to the stack and finally, after popping them
                        off again. To do this, it is necessary to access the <code>stack</code> attribute contained within <code>stack_instance</code>
                        which is possible with dot notation and the commonly known built-in Python function len(array name).  All of the
                        elements pushed onto the array previously were subsequently popped-off.  Intuitively, then the current length of
                        the array is expected to be zero.</p>
                    <div class="code-block">
<pre>
<p-prt>print</p-prt>(<p-prt>len</p-prt>(stack_instance.stack))  # 0
</pre>
                    </div>
                    <p>These expectations satisfied, lets <code>push</code> a few new elements onto the <code>stack</code> array in <code>stack_instance</code> and then get the list length. </p>
                    <div class="code-block">
<pre>
stack_instance.push(<p-chr>"a"</p-chr>)
stack_instance.push(<p-chr>"b"</p-chr>)
stack_instance.push(<p-chr>"c"</p-chr>)

<p-prt>print</p-prt>(<p-prt>len</p-prt>(stack_instance.stack))  # 3
</pre>
                    </div>
                    <p>Now if two elements are 'popped-off' we should see the following results.</p>
                    <div class="code-block">
<pre>
<p-prt>print</p-prt>(stack_instance.pop())  # c
<p-prt>print</p-prt>(stack_instance.pop())  # b

<p-prt>print</p-prt>(<p-prt>len</p-prt>(stack_instance.stack))  # 1
</pre>
                    </div>
                    <p>Of course, a benefit of creating a class object is gaining the ability to create many instances. So it would be good to check that these
                        instances behave independently. Let's create a <code>tiny_stack</code> instance, add some elements to its
                        <code>stack</code> and perform the same
                        checks as previously, remembering that <code>stack_instance.stack</code> already has 1 element with the value "a".</p>
                    <div class="code-block">
<pre>
tiny_stack = Stack()

tiny_stack.push(<p-int>30</p-int>)
tiny_stack.push(<p-int>20</p-int>)
tiny_stack.push(<p-int>10</p-int>)

<p-prt>print</p-prt>(<p-prt>len</p-prt>(stack_instance.stack))  # 3
</pre>
                    </div>
                    <div class="code-block">
<pre>
<p-prt>print</p-prt>(tiny_stack.pop())  # 10

<p-prt>print</p-prt>(<p-prt>len</p-prt>(stack_instance.stack))  # 2
</pre>
                    </div>
                    <p>An additional way to verify that autonomous instances have been created would be to console print the contents of the lists like so. </p>
                    <div class="code-block">
<pre>
<p-prt>print</p-prt>(tiny_stack.stack_list)  # [30, 20]

<p-prt>print</p-prt>(stack_instance.stack_list)  # ['a']
</pre>
                    </div>
                    <p>Comparing the object-oriented approach versus the procedural reveals:</p>
                    <ul>
                        <li>a certain portability owing to the encapsulation of the data with the methods acting on the data in the class object;</li>
                        <li>the ease of creating new instantiations of class objects for different purposes;</li>
                        <li>an assurance of consistency of operation (i.e. each instance will have the same access to attributes and methods);</li>
                        <li>a feel of write once use once with regard to procedural programming;</li>
                        <li>there are no silver bullets leaving the programmer to opt for the correct tool for each project.</li>
                    </ul>

<!--                    <div class="code-block">
<pre>
<p-kw>class</p-kw> Recipe():
   <p-kw>def</p-kw><p-bi>__init__</p-bi>(<p-slf>self</p-slf>):
      <p-kw>return</p-kw> <p-str>"I love to cook and code."</p-str>
</pre>
                    </div>

                    <div class="code-block">
<pre>
<p-kw>class</p-kw> Recipe():
   <p-kw>def</p-kw><p-bi>__init__</p-bi>(<p-slf>self</p-slf>):
      <p-kw>return</p-kw> <p-str>"I love to cook and code."</p-str>
</pre>
                    </div>-->
                </article>
            </section>
            <section id="private_attributes" class="main-section">
                <header><h2>Private Attributes</h2></header>
                <article>
                    <blockquote>"“Private” instance variables that cannot be accessed except from inside an object don’t exist in Python. However, there is a convention that is followed by most Python code: a name prefixed with an
                    underscore (e.g. _spam) should be treated as a non-public part of the API (whether it is a function,
                    a method or a data member).<a class="ref" href="#ref8"><sup>8</sup></a>"</blockquote>
                    <p><strong>Name mangling</strong> is used to access and update overridden attributes without conflicting with subclass definitions. Taking the form
                        <code>_classname__identifier</code>, name mangling requires the identifier of concern to be prepended with atleast
                        two underscore characters, and no more than one as a suffix. <q>...Name mangling rules are designed mostly to avoid
                            accidents; it is still possible to access or modify a variable that is
                            considered private.<a class="ref" href="#ref9"><sup>9</sup></a></q></p>
                    <p>The current form of the <code>Stack</code> class object has a safety issue in that the attributes
                        are accessible from outside the class. Ideally, the <code>stack</code> list property should only
                        be accessible from within the class object itself.  A name mangling type solution can at least approximate a private
                        attribute in terms of safety through a special access syntax.  The <code>push</code> and <code>pop</code> methods
                        need to be accessible as they are and therefore require no amendments.</p>
                    <p>The following illustrates the necessary adjustments to create this private attribute for use with name mangling.</p>
                    <div class="code-block">
<pre>
<p-kw>class</p-kw> Stack:
    <p-kw>def </p-kw><p-bi>__init__</p-bi>(<p-slf>self</p-slf>):
        <p-slf>self</p-slf>.__stack = []

    <p-kw>def</p-kw><p-name> push</p-name>(<p-slf>self</p-slf>, value):
        <p-slf>self</p-slf>.__stack.append(value)

    <p-kw>def</p-kw><p-name> pop</p-name>(<p-slf>self</p-slf>):
        element = <p-slf>self</p-slf>.__stack[-<p-int>1</p-int>]
        <p-kw>del</p-kw> <p-slf>self</p-slf>.__stack[-<p-int>1</p-int>]
        <p-kw>return</p-kw> element
</pre>
                    </div>

                    <p>Now anytime the <code>__stack</code> list is referenced from outside the class, the name mangling syntax must be used
                        otherwise an <code>AttributeError</code> will be raised.  A new instance can now be created, <code>push</code> some items to the
                        <code>__stack</code>, <code>pop</code> an item from the stack and print the length of the <code>__stack</code>
                    to the console.</p>
                    <div class="code-block">
<pre>
stack_instance = Stack()

stack_instance.push(<p-int>3</p-int>)
stack_instance.push(<p-int>2</p-int>)
stack_instance.push(<p-int>1</p-int>)

<p-prt>print</p-prt>(stack_instance.pop())  # 1

<p-prt>print</p-prt>(<p-prt>len</p-prt>(stack_instance._Stack__stack))  # 2
</pre>
                    </div>
                    <p>In summary, encapsulation of data and functions in an object is fundamental to object-oriented programming.  In Python:</p>
                    <ul>
                        <li>it is not possible to make attributes truly private in the way it is in Swift and other languages;</li>
                        <li>private or protected attributes make it possible for subclasses to override attributes in a more controlled way;</li>
                        <li>it is possible to add an element of safety through the use of name mangling;</li>
                        <li>name mangling helps to avoid amending attributes accidentally;</li>
                        <li>if the name mangling syntax is not employed an <code>AttributeError</code> is raised;</li>
                    </ul>
                </article>
            </section>
            <section id="properties" class="main-section">
                <header><h2>Properties</h2></header>
                <article>
                    <h3>Instance variables</h3>
                    <p>Properties can be added to a class object with a constructor as shown above with the Stack class, or properties can
                    be added at anytime during the object's life cycle.  The following considerations should be kept in mind:
                    </p>
                    <ul>
                        <li>different sets of properties may be contained within different class instances of the same class object; </li>
                        <li>each object has its own independent properties;</li>
                        <li>specific objects can be queried for required properties;</li>
                    </ul>
                    <p>Let's illustrate the concept of <strong>instance variables</strong> with a new class object named <code>Parking</code>.
                    A <code>Parking</code> object by default will have a space large enough for one car and will have a
                        <code>set_garage</code> method to set the space inside a garage.</p>
                    <div class="code-block">
<pre>
<p-kw>class</p-kw> Parking:
   <p-kw>def</p-kw> <p-bi>__init__</p-bi>(<p-slf>self</p-slf>, val=<p-int>1</p-int>):
      <p-slf>self</p-slf>.spaces = val

   <p-kw>def</p-kw> <p-name>set_garage</p-name>(<p-slf>self</p-slf>, val=<p-kw>False</p-kw>):
      <p-slf>self</p-slf>.garage = val
      <p-kw>return</p-kw> <p-slf>self</p-slf>.garage
</pre>
                    </div>
                    <p>Now let's create a <code>my_parking</code> instance of the class object and print its properties to the console.</p>
                    <div class="code-block">
<pre>
my_parking = Parking()

<p-prt>print</p-prt>(my_parking.spaces)  # 1
<p-prt>print</p-prt>(my_parking.set_garage())  # False
</pre>
                    </div>
                    <p>The writeable object properties<a class="ref" href="#ref10"><sup>10</sup></a> can be viewed with the
                        <code>__dict__</code> special attribute that all class objects/instances take by default.  This dictionary includes
                    all of the attributes created previously as shown below.</p>
                    <div class="code-block">
<pre>
<p-prt>print</p-prt>(my_parking.<p-bi>__dict__</p-bi>)  # {'spaces': 1, 'garage': False}
</pre>
                    </div>
                    <p>A new property can be added to the <code>my_parking</code> instance through the use of dot notation.  Adding a
                        <code>has_lighting</code> property is simply a matter of assigning it a value and to check the successful assignment
                    it can be printed to the console and viewing the instance dictionary.</p>
                    <div class="code-block">
<pre>
my_parking.has_lighting = <p-kw>True</p-kw>
<p-prt>print</p-prt>(my_parking.has_lighting)  # True

<p-prt>print</p-prt>(my_parking.<p-bi>__dict__</p-bi>)  # {'spaces': 1, 'garage': False, 'has_lighting': True}
</pre>
                    </div>
                    <p>Interestingly, the dictionary values can be amended in the traditional way as follows.</p>
                    <div class="code-block">
<pre>
my_parking.<p-bi>__dict__</p-bi>[<p-chr>'spaces'</p-chr>] = <p-int>5</p-int>
<p-prt>print</p-prt>(my_parking.<p-bi>__dict__</p-bi>)  # {'spaces': 5, 'garage': False, 'has_lighting': True}
</pre>
                    </div>
                    <h3>Class variables</h3>
                    <p>The <strong>instance variable</strong> examples above illustrates that they store instance specific data.
                        <strong>Class variables</strong> apply to all instances to reflect class-wide data.<a class="ref" href="#ref11"><sup>11</sup></a></p>
                    <p>Assuming that the <code>Parking</code> object is needed to track the total number of spaces available, in other words, each time an
                        instance is created a class variable is updated with the number of parking spaces contributed by the instance.  The value held by
                    the class variable can then be returned on request.  Let's amend the class definition as follows.</p>
                    <div class="code-block">
<pre>
<p-kw>class</p-kw> Parking:
   total_spaces = 0  # track total number of spaces created by all Parking instances

   <p-kw>def</p-kw> <p-bi>__init__</p-bi>(<p-slf>self</p-slf>, val=<p-int>1</p-int>):
      <p-slf>self</p-slf>.spaces = val
      Parking.total_spaces += val  # add parking spaces val to total spaces.

   <p-kw>def</p-kw> <p-name>set_garage</p-name>(<p-slf>self</p-slf>, val=<p-kw>False</p-kw>):
      <p-slf>self</p-slf>.garage = val
      <p-kw>return</p-kw> <p-slf>self</p-slf>.garage
</pre>
                    </div>
                    <p>Now let's test the class object by creating a couple of instances and printing the values of <code>total_spaces</code>
                    to the console.</p>
                    <div class="code-block">
<pre>
sams_parking = Parking()
<p-prt>print</p-prt>(Parking.total_spaces)  # 1

amys_parking = Parking(<p-int>10</p-int>)
<p-prt>print</p-prt>(Parking.total_spaces)  # 11
</pre>
                    </div>
                    <p>Clarifying the code above, the <code>sams_parking</code> instance will create one parking space by default.
                        An additional ten spaces are created on the instantiation of <code>amys_parking</code>, hence the value of
                        <samp>11</samp> printed to the console.</p>
                    <p>To further show that the class variable is independent of any particular instance lets print the <code>__dict__</code>
                    object to the console for both instances created previously.</p>
                    <div class="code-block">
<pre>
<p-prt>print</p-prt>(sams_parking.<p-bi>__dict__</p-bi>)  # {'spaces': 1}
<p-prt>print</p-prt>(amys_parking.<p-bi>__dict__</p-bi>)  # {'spaces': 10}
</pre>
                    </div>
                    <p>The console prints reveal the same instance variable for each instance with the instantiation value held for
                        <code>sams_parking</code> and <code>amys_parking</code>, but no key for <code>total_spaces</code>.  However,
                        if the <code>__dict__</code> for the <code>Parking</code> class object is printed to the console, the key-value
                    pair for the <code>total_spaces</code> class variable is present including the expected corresponding value as
                        shown below.</p>
                    <div class="code-block">
<pre>
<p-prt>print</p-prt>(Parking.<p-bi>__dict__</p-bi>)  # {'__module__': '__main__', 'total_spaces': 11, '__init__': ...}
</pre>
                    </div>
                    <p>Interestingly, there is a built-in function named <code>hasattr</code> that takes two arguments:
                        an instance name and a variable name; and returns a boolean corresponding to whether the variable name is an
                    attribute of the class instance.<a class="ref" href="#ref12"><sup>12</sup></a></p>
                    <div class="code-block">
<pre>
<p-prt>print</p-prt>(<p-prt>hasattr</p-prt>(amys_parking, <p-chr>'spaces'</p-chr>))  # True
<p-prt>print</p-prt>(<p-prt>hasattr</p-prt>(amys_parking, <p-chr>'some_variable'</p-chr>))  # False
</pre>
                    </div>
                    <p>In conclusion, <strong>instance variables</strong> are utilized for object instances, while <strong>class variables</strong> 
                    are defined to apply across an entire class of objects.  Care is required when a class variable is declared, in terms of 
                    its true meaning and how it might be managed.  Consider the case where a <code>parking</code> instance is no longer required.
                    There is no mechanism in place to adjust the <code>total_spaces</code> class variable if an instance were discarded.</p>

                </article>
            </section>
            <section id="section_5" class="main-section">
                <header><h2>Section 5</h2></header>
                <article>
                    <p>Nine</p>
                    <p>Ten</p>
                    <p>Lorem ipsum, dolor sit amet consectetur adipisicing elit. Repudiandae sapiente,
                        quas fuga numquam expedita totam labore ullam, eos eaque facere voluptatum
                        consequatur quisquam beatae, aspernatur blanditiis esse nam et quae provident
                        architecto id temporibus aperiam distinctio eligendi. Repudiandae, ex optio!</p>
                    <code>Five</code>
                    <ul>
                        <li>One</li>
                        <li>Two</li>
                        <li>Three</li>
                        <li>Four</li>
                        <li>Five</li>
                    </ul>
                </article>
            </section>
            <section id="references" class="main-section">
                <header><h2>References</h2></header>
                <article>
                    <p><sup id="ref1">1</sup> Wikipedia contributors. (2023, June 22). Object-oriented programming. In
                    Wikipedia, The Free Encyclopedia. Retrieved 12:10, July 5, 2023, from
                    <a href="https://en.wikipedia.org/w/index.php?title=Object-oriented_programming&oldid=1161421962">https://en.wikipedia.org/w/index.php?title=Object-oriented_programming&oldid=1161421962</a>
                    </p>
                    <p><sup id="ref2">2</sup> Wikipedia contributors. (2022, December 23). Single-responsibility
                        principle. In Wikipedia, The Free Encyclopedia. Retrieved 11:49, July 5, 2023, from
                        <a href="https://en.wikipedia.org/w/index.php?title=Single-responsibility_principle&oldid=1129050472">https://en.wikipedia.org/w/index.php?title=Single-responsibility_principle&oldid=1129050472</a>
                    </p>
                    <p><sup id="ref3">3</sup> Wikipedia contributors. (2023, June 27). SOLID. In Wikipedia, The Free
                        Encyclopedia. Retrieved 12:01, July 5, 2023, from
                        <a href="https://en.wikipedia.org/w/index.php?title=SOLID&oldid=1162113306">https://en.wikipedia.org/w/index.php?title=SOLID&oldid=1162113306</a>
                    </p>
                    <p><sup id="ref4">4</sup> PEP 8 – Style Guide for Python Code. (2013, August 1). Retrieved 16:58,
                        July 7, 2023, from
                        <a href="https://peps.python.org/pep-0008/#class-names">https://peps.python.org/pep-0008/#class-names</a>
                    </p>
                    <p><sup id="ref5">5</sup> The Python Language Reference, 3.3.1 Basic customization, para 3. n.d.
                        Retrieved 13:47, July 9, 2023, from
                        <a href="https://docs.python.org/3/reference/datamodel.html#index-47">https://docs.python.org/3/reference/datamodel.html#index-47</a>
                    </p>
                    <p><sup id="ref6">6</sup> The Python Tutorial, 9 Classes, 9.3.2 Class objects, para 4. n.d.
                        Retrieved 18:40, July 9, 2023, from
                        <a href="https://docs.python.org/3/tutorial/classes.html#class-objects">https://docs.python.org/3/tutorial/classes.html#class-objects</a>
                    </p>
                    <p><sup id="ref7">7</sup> The Python Tutorial, 9 Classes, 9.3.3 Instance objects, para 3. n.d.
                        Retrieved 19:04, July 9, 2023, from
                        <a href="https://docs.python.org/3/tutorial/classes.html#instance-objects">https://docs.python.org/3/tutorial/classes.html#instance-objects</a>
                    </p>
                    <p><sup id="ref8">8</sup> The Python Tutorial, 9 Classes, 9.6 Private Variables, para 1. n.d.
                        Retrieved 11:39, July 13, 2023, from
                        <a href="https://docs.python.org/3/tutorial/classes.html#private-variables">https://docs.python.org/3/tutorial/classes.html#private-variables</a>
                    </p>
                    <p><sup id="ref9">9</sup> The Python Tutorial, 9 Classes, 9.6 Private Variables, para 5. n.d.
                        Retrieved 14:09, July 13, 2023, from
                        <a href="https://docs.python.org/3/tutorial/classes.html#private-variables">https://docs.python.org/3/tutorial/classes.html#private-variables</a>
                    </p>
                    <p><sup id="ref10">10</sup> The Python Standard Library, Built-in Types, Special Attributes, para 2. n.d.
                        Retrieved 20:49, July 14, 2023, from
                        <a href="https://docs.python.org/3/library/stdtypes.html#special-attributes">https://docs.python.org/3/library/stdtypes.html#special-attributes</a>
                    </p>
                    <p><sup id="ref11">11</sup> The Python Tutorial, 9 Classes, 9.3.5 Class and Instance Variables, para 1. n.d.
                        Retrieved 14:09, July 13, 2023, from
                        <a href="https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables">https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables</a>
                    </p>
                    <p><sup id="ref12">12</sup>The Python Standard Library, Built-in Functions, hasattr, para 1. n.d.,
                        Retrieved 21:01, July 15, 2023, from
                        <a href="https://docs.python.org/3/library/functions.html#hasattr">https://docs.python.org/3/library/functions.html#hasattr</a>
                    </p>

                    <a href="#cite_note-ub-old-web-solid-1">[1]</a>
                </article>
            </section>
        </div>
    </main>
</div>

</body>
</html>